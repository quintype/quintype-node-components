{"version":3,"sources":["../node_modules/global/document.js","../node_modules/global/window.js","../node_modules/@brightcove/react-player-loader/dist/brightcove-react-player-loader.es.js"],"names":["ReactPlayerLoader","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_assertThisInitialized","self","ReferenceError","_extends$1","version","version$1","_typeof","Symbol","iterator","obj","JSON_ALLOWED_PARAMS","IFRAME_ALLOWED_QUERY_PARAMS","getQueryParamValue","params","undefined","indexOf","encodeURIComponent","JSON","stringify","x","String","trim","getQueryString","keys","filter","k","reduce","qs","value","brightcovePlayerUrl","_ref","accountId","_ref$base","base","_ref$playerId","playerId","_ref$embedId","embedId","_ref$iframe","iframe","_ref$minified","minified","_ref$queryParams","queryParams","ext","charAt","substring","VERSION","DEFAULTS","embedType","Promise","window","refNodeInsert","DEFAULT_ASPECT_RATIO","DEFAULT_IFRAME_HORIZONTAL_PLAYLIST","DEFAULT_MAX_WIDTH","EMBED_TAG_NAME_VIDEO","EMBED_TAG_NAME_VIDEOJS","EMBED_TYPE_IN_PAGE","EMBED_TYPE_IFRAME","REF_NODE_INSERT_APPEND","REF_NODE_INSERT_PREPEND","REF_NODE_INSERT_BEFORE","REF_NODE_INSERT_AFTER","REF_NODE_INSERT_REPLACE","JSON_ALLOWED_ATTRS","BASE_URL","getUrl","playerUrl","embedOptions","unminified","getBaseUrl","setBaseUrl","baseUrl","urls","isEl","el","Boolean","nodeType","isElInDom","parentNode","createIframeEmbed","document","createElement","setAttribute","src","createInPageEmbed","paramsToAttrs","adConfigId","applicationId","catalogSearch","catalogSequence","deliveryConfigId","playlistId","playlistVideoId","poster","videoId","tagName","forEach","classList","add","wrapResponsive","responsive","style","position","top","right","bottom","left","width","height","aspectRatio","iframeHorizontalPlaylist","maxWidth","split","map","Number","inner","paddingTop","appendChild","outer","display","wrapPip","pip","wrapEmbed","embed","insertEmbed","refNode","refNodeParent","wrapped","insertBefore","nextElementSibling","replaceChild","firstChild","playlist","playlistTagName","legacy","onEmbedCreated","result","createEmbed","actualCache","Map","store","props","set","has","get","clear","fn","playerScriptCache","REGEX_PLAYER_EMBED","getBcGlobalKeys","bc","test","getGlobalKeys","disposeAll","videojs","players","p","dispose","reset","Array","slice","querySelectorAll","removeChild","detectPlayers","matches","match","env","isFn","isValidEmbedType","isValidTagName","isValidRootInsert","checkParams","options","Error","resolveRefNode","querySelector","initPlayer","resolve","reject","player","bcinfo","PLAYER_LOADER","message","type","ref","loadPlayer","script","onload","onerror","async","charset","brightcovePlayerLoader","parameters","onSuccess","onFailure","err","expose","defineProperty","configurable","enumerable","writable","arr","UPDATEABLE_PROPS","logError","console","error","_React$Component","_this","setRefNode","bind","_proto","_this2","disposePlayer","userSuccess","userFailure","isMounted_","one","REACT_PLAYER_LOADER","attrs","manualReloadFromPropChanges","originalBaseUrl","findPlaylistVideoIdIndex_","isArray","_playlist$i","id","referenceId","createPlaybackAPICallback_","requestType","changes","_this3","data","startingIndex","catalog","load","updatePlayer","catalogParams","usingPlugin","callback","getLazySequence","q","_callback","currentItem","componentDidMount","componentDidUpdate","prevProps","_this4","acc","previous","current","some","componentWillUnmount","render","className","React","Component"],"mappings":"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","file":"brightcove-react-player-loader.es.bc5a870b.js","sourceRoot":"..","sourcesContent":["var topLevel = typeof global !== 'undefined' ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = require('min-document');\n\nvar doccy;\n\nif (typeof document !== 'undefined') {\n    doccy = document;\n} else {\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n}\n\nmodule.exports = doccy;\n","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","/*! @name @brightcove/react-player-loader @version 1.4.2 @license Apache-2.0 */\nimport React from 'react';\nimport document from 'global/document';\nimport window from 'global/window';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/*! @name @brightcove/player-loader @version 1.8.0 @license Apache-2.0 */\n\nfunction _extends$1() {\n  _extends$1 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends$1.apply(this, arguments);\n}\n\nvar version = \"1.8.0\";\n\n/*! @name @brightcove/player-url @version 1.2.0 @license Apache-2.0 */\nvar version$1 = \"1.2.0\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n// The parameters that may include JSON.\nvar JSON_ALLOWED_PARAMS = ['catalogSearch', 'catalogSequence'];\n\n// The parameters that may be set as query string parameters for iframes.\nvar IFRAME_ALLOWED_QUERY_PARAMS = ['adConfigId', 'applicationId', 'catalogSearch', 'catalogSequence', 'playlistId', 'playlistVideoId', 'videoId'];\n\n/**\n * Gets the value of a parameter and encodes it as a string.\n *\n * For certain keys, JSON is allowed and will be encoded.\n *\n * @private\n * @param   {Object} params\n *          A parameters object. See README for details.\n *\n * @param   {string} key\n *          The key in the params object.\n *\n * @return  {string|undefined}\n *          The encoded value - or `undefined` if none.\n */\nvar getQueryParamValue = function getQueryParamValue(params, key) {\n\n  if (!params || params[key] === undefined) {\n    return;\n  }\n\n  // If it's not a string, such as with a catalog search or sequence, we\n  // try to encode it as JSON.\n  if (typeof params[key] !== 'string' && JSON_ALLOWED_PARAMS.indexOf(key) !== -1) {\n    try {\n      return encodeURIComponent(JSON.stringify(params[key]));\n    } catch (x) {\n\n      // If it's not a string and we can't encode as JSON, it's ignored entirely.\n      return;\n    }\n  }\n\n  return encodeURIComponent(String(params[key]).trim()) || undefined;\n};\n\n/**\n * In some cases, we need to add query string parameters to an iframe URL.\n *\n * @private\n * @param   {Object} params\n *          An object of query parameters.\n *\n * @return  {string}\n *          A query string starting with `?`. If no valid parameters are given,\n *          returns an empty string.\n */\nvar getQueryString = function getQueryString(params) {\n  return Object.keys(params).filter(function (k) {\n    return IFRAME_ALLOWED_QUERY_PARAMS.indexOf(k) !== -1;\n  }).reduce(function (qs, k) {\n    var value = getQueryParamValue(params, k);\n\n    if (value !== undefined) {\n      qs += qs ? '&' : '?';\n      qs += encodeURIComponent(k) + '=' + value;\n    }\n\n    return qs;\n  }, '');\n};\n\n/**\n * Generate a URL to a Brightcove Player.\n *\n * @param  {Object}  params\n *         A set of parameters describing the player URL to create.\n *\n * @param  {string}  params.accountId\n *         A Brightcove account ID.\n *\n * @param  {string}  [params.playerId=\"default\"]\n *         A Brightcove player ID.\n *\n * @param  {string}  [params.embedId=\"default\"]\n *         A Brightcove player embed ID.\n *\n * @param  {boolean} [params.iframe=false]\n *         Whether to return a URL for an HTML document to be embedded in\n *         an iframe.\n *\n * @param  {boolean} [params.minified=true]\n *         When the `iframe` argument is `false`, this can be used to control\n *         whether the minified or unminified JavaScript URL is returned.\n *\n * @param  {string} [params.base=\"https://players.brightcove.net\"]\n *         A base CDN protocol and hostname. Mainly used for testing.\n *\n * @return {string}\n *         A URL to a Brightcove Player.\n */\nvar brightcovePlayerUrl = function brightcovePlayerUrl(_ref) {\n  var accountId = _ref.accountId,\n      _ref$base = _ref.base,\n      base = _ref$base === undefined ? 'https://players.brightcove.net' : _ref$base,\n      _ref$playerId = _ref.playerId,\n      playerId = _ref$playerId === undefined ? 'default' : _ref$playerId,\n      _ref$embedId = _ref.embedId,\n      embedId = _ref$embedId === undefined ? 'default' : _ref$embedId,\n      _ref$iframe = _ref.iframe,\n      iframe = _ref$iframe === undefined ? false : _ref$iframe,\n      _ref$minified = _ref.minified,\n      minified = _ref$minified === undefined ? true : _ref$minified,\n      _ref$queryParams = _ref.queryParams,\n      queryParams = _ref$queryParams === undefined ? null : _ref$queryParams;\n\n  var ext = '';\n\n  if (iframe) {\n    ext += 'html';\n  } else {\n    if (minified) {\n      ext += 'min.';\n    }\n    ext += 'js';\n  }\n\n  if (base.charAt(base.length - 1) === '/') {\n    base = base.substring(0, base.length - 1);\n  }\n\n  var qs = '';\n\n  if (iframe && queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) === 'object') {\n    qs = getQueryString(queryParams);\n  }\n\n  accountId = encodeURIComponent(accountId);\n  playerId = encodeURIComponent(playerId);\n  embedId = encodeURIComponent(embedId);\n\n  return base + '/' + accountId + '/' + playerId + '_' + embedId + '/index.' + ext + qs;\n};\n\n/**\n * The version of this module.\n *\n * @type {string}\n */\nbrightcovePlayerUrl.VERSION = version$1;\n\nvar DEFAULTS = {\n  embedId: 'default',\n  embedType: 'in-page',\n  playerId: 'default',\n  Promise: window.Promise,\n  refNodeInsert: 'append'\n};\nvar DEFAULT_ASPECT_RATIO = '16:9';\nvar DEFAULT_IFRAME_HORIZONTAL_PLAYLIST = false;\nvar DEFAULT_MAX_WIDTH = '100%';\nvar EMBED_TAG_NAME_VIDEO = 'video';\nvar EMBED_TAG_NAME_VIDEOJS = 'video-js';\nvar EMBED_TYPE_IN_PAGE = 'in-page';\nvar EMBED_TYPE_IFRAME = 'iframe';\nvar REF_NODE_INSERT_APPEND = 'append';\nvar REF_NODE_INSERT_PREPEND = 'prepend';\nvar REF_NODE_INSERT_BEFORE = 'before';\nvar REF_NODE_INSERT_AFTER = 'after';\nvar REF_NODE_INSERT_REPLACE = 'replace';\nvar JSON_ALLOWED_ATTRS = ['catalogSearch', 'catalogSequence'];\n\nvar BASE_URL = 'https://players.brightcove.net/';\n/**\n * Gets the URL to a player on CDN.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {string}\n *         A URL.\n */\n\nvar getUrl = function getUrl(params) {\n  if (params.playerUrl) {\n    return params.playerUrl;\n  }\n\n  var accountId = params.accountId,\n      playerId = params.playerId,\n      embedId = params.embedId,\n      embedOptions = params.embedOptions;\n  var iframe = params.embedType === EMBED_TYPE_IFRAME;\n  return brightcovePlayerUrl({\n    accountId: accountId,\n    playerId: playerId,\n    embedId: embedId,\n    iframe: iframe,\n    base: BASE_URL,\n    // The unminified embed option is the exact reverse of the minified option\n    // here.\n    minified: embedOptions ? !embedOptions.unminified : true,\n    // Pass the entire params object as query params. This is safe because\n    // @brightcove/player-url only accepts a whitelist of parameters. Anything\n    // else will be ignored.\n    queryParams: params\n  });\n};\n/**\n * Function used to get the base URL - primarily for testing.\n *\n * @private\n * @return {string}\n *         The current base URL.\n */\n\n\nvar getBaseUrl = function getBaseUrl() {\n  return BASE_URL;\n};\n/**\n * Function used to set the base URL - primarily for testing.\n *\n * @private\n * @param {string} baseUrl\n *        A new base URL (instead of Brightcove CDN).\n */\n\n\nvar setBaseUrl = function setBaseUrl(baseUrl) {\n  BASE_URL = baseUrl;\n};\n\nvar urls = {\n  getUrl: getUrl,\n  getBaseUrl: getBaseUrl,\n  setBaseUrl: setBaseUrl\n};\n\n/**\n * Is this value an element?\n *\n * @param  {Element} el\n *         A maybe element.\n *\n * @return {boolean}\n *         Whether or not the value is a element.\n */\n\nvar isEl = function isEl(el) {\n  return Boolean(el && el.nodeType === 1);\n};\n/**\n * Is this value an element with a parent node?\n *\n * @param  {Element} el\n *         A maybe element.\n *\n * @return {boolean}\n *         Whether or not the value is a element with a parent node.\n */\n\n\nvar isElInDom = function isElInDom(el) {\n  return Boolean(isEl(el) && el.parentNode);\n};\n/**\n * Creates an iframe embed code.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {Element}\n *         The DOM element that will ultimately be passed to the `bc()` function.\n */\n\n\nvar createIframeEmbed = function createIframeEmbed(params) {\n  var el = document.createElement('iframe');\n  el.setAttribute('allow', 'autoplay;encrypted-media;fullscreen');\n  el.setAttribute('allowfullscreen', 'allowfullscreen');\n  el.src = urls.getUrl(params);\n  return el;\n};\n/**\n * Creates an in-page embed code.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {Element}\n *         The DOM element that will ultimately be passed to the `bc()` function.\n */\n\n\nvar createInPageEmbed = function createInPageEmbed(params) {\n  var embedOptions = params.embedOptions; // We DO NOT include the data-account, data-player, or data-embed attributes\n  // here because we will be manually initializing the player.\n\n  var paramsToAttrs = {\n    adConfigId: 'data-ad-config-id',\n    applicationId: 'data-application-id',\n    catalogSearch: 'data-catalog-search',\n    catalogSequence: 'data-catalog-sequence',\n    deliveryConfigId: 'data-delivery-config-id',\n    playlistId: 'data-playlist-id',\n    playlistVideoId: 'data-playlist-video-id',\n    poster: 'poster',\n    videoId: 'data-video-id'\n  };\n  var tagName = embedOptions && embedOptions.tagName || EMBED_TAG_NAME_VIDEOJS;\n  var el = document.createElement(tagName);\n  Object.keys(paramsToAttrs).filter(function (key) {\n    return params[key];\n  }).forEach(function (key) {\n    var value; // If it's not a string, such as with a catalog search or sequence, we\n    // try to encode it as JSON.\n\n    if (typeof params[key] !== 'string' && JSON_ALLOWED_ATTRS.indexOf(key) !== -1) {\n      try {\n        value = JSON.stringify(params[key]); // If it fails, don't set anything.\n      } catch (x) {\n        return;\n      }\n    } else {\n      value = String(params[key]).trim();\n    }\n\n    el.setAttribute(paramsToAttrs[key], value);\n  });\n  el.setAttribute('controls', 'controls');\n  el.classList.add('video-js');\n  return el;\n};\n/**\n * Wraps an element in responsive intrinsic ratio elements.\n *\n * @private\n * @param  {string} embedType\n *         The type of the embed.\n *\n * @param  {Object} embedOptions\n *         Embed options from the params.\n *\n * @param  {Element} el\n *         The DOM element.\n *\n * @return {Element}\n *         A new element (if needed).\n */\n\n\nvar wrapResponsive = function wrapResponsive(embedType, embedOptions, el) {\n  if (!embedOptions.responsive) {\n    return el;\n  }\n\n  el.style.position = 'absolute';\n  el.style.top = '0px';\n  el.style.right = '0px';\n  el.style.bottom = '0px';\n  el.style.left = '0px';\n  el.style.width = '100%';\n  el.style.height = '100%';\n\n  var responsive = _extends$1({\n    aspectRatio: DEFAULT_ASPECT_RATIO,\n    iframeHorizontalPlaylist: DEFAULT_IFRAME_HORIZONTAL_PLAYLIST,\n    maxWidth: DEFAULT_MAX_WIDTH\n  }, embedOptions.responsive); // This value is validate at a higher level, so we can trust that it's in the\n  // correct format.\n\n\n  var aspectRatio = responsive.aspectRatio.split(':').map(Number);\n  var inner = document.createElement('div');\n  var paddingTop = aspectRatio[1] / aspectRatio[0] * 100; // For iframes with a horizontal playlist, the playlist takes up 20% of the\n  // vertical space (if shown); so, adjust the vertical size of the embed to\n  // avoid black bars.\n\n  if (embedType === EMBED_TYPE_IFRAME && responsive.iframeHorizontalPlaylist) {\n    paddingTop *= 1.25;\n  }\n\n  inner.style.paddingTop = paddingTop + '%';\n  inner.appendChild(el);\n  var outer = document.createElement('div');\n  outer.style.position = 'relative';\n  outer.style.display = 'block';\n  outer.style.maxWidth = responsive.maxWidth;\n  outer.appendChild(inner);\n  return outer;\n};\n/**\n * Wraps an element in a Picture-in-Picture plugin container.\n *\n * @private\n * @param  {Object} embedOptions\n *         Embed options from the params.\n *\n * @param  {Element} el\n *         The DOM element.\n *\n * @return {Element}\n *         A new element (if needed).\n */\n\n\nvar wrapPip = function wrapPip(embedOptions, el) {\n  if (!embedOptions.pip) {\n    return el;\n  }\n\n  var pip = document.createElement('div');\n  pip.classList.add('vjs-pip-container');\n  pip.appendChild(el);\n  return pip;\n};\n/**\n * Wraps a bare embed element with necessary parent elements, depending on\n * embed options given in params.\n *\n * @private\n * @param  {string} embedType\n *         The type of the embed.\n *\n * @param  {Object} embedOptions\n *         Embed options from the params.\n *\n * @param  {Element} embed\n *         The embed DOM element.\n *\n * @return {Element}\n *         A new element (if needed) or the embed itself.\n */\n\n\nvar wrapEmbed = function wrapEmbed(embedType, embedOptions, embed) {\n  if (!embedOptions) {\n    return embed;\n  }\n\n  return wrapPip(embedOptions, wrapResponsive(embedType, embedOptions, embed));\n};\n/**\n * Inserts a previously-created embed element into the page based on params.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Element} embed\n *         The embed DOM element.\n *\n * @return {Element}\n *         The embed DOM element.\n */\n\n\nvar insertEmbed = function insertEmbed(params, embed) {\n  var refNode = params.refNode,\n      refNodeInsert = params.refNodeInsert;\n  var refNodeParent = refNode.parentNode; // Wrap the embed, if needed, in container elements to support various\n  // plugins.\n\n  var wrapped = wrapEmbed(params.embedType, params.embedOptions, embed); // Decide where to insert the wrapped embed.\n\n  if (refNodeInsert === REF_NODE_INSERT_BEFORE) {\n    refNodeParent.insertBefore(wrapped, refNode);\n  } else if (refNodeInsert === REF_NODE_INSERT_AFTER) {\n    refNodeParent.insertBefore(wrapped, refNode.nextElementSibling || null);\n  } else if (refNodeInsert === REF_NODE_INSERT_REPLACE) {\n    refNodeParent.replaceChild(wrapped, refNode);\n  } else if (refNodeInsert === REF_NODE_INSERT_PREPEND) {\n    refNode.insertBefore(wrapped, refNode.firstChild || null); // Append is the default.\n  } else {\n    refNode.appendChild(wrapped);\n  } // If the playlist embed option is provided, we need to add a playlist element\n  // immediately after the embed. This has to happen after the embed is inserted\n  // into the DOM (above).\n\n\n  if (params.embedOptions && params.embedOptions.playlist) {\n    var playlistTagName = params.embedOptions.playlist.legacy ? 'ul' : 'div';\n    var playlist = document.createElement(playlistTagName);\n    playlist.classList.add('vjs-playlist');\n    embed.parentNode.insertBefore(playlist, embed.nextElementSibling || null);\n  } // Clean up internal reference to the refNode to avoid potential memory\n  // leaks in case the params get persisted somewhere. We won't need it beyond\n  // this point.\n\n\n  params.refNode = null; // Return the original embed element that can be passed to `bc()`.\n\n  return embed;\n};\n/**\n * Handles `onEmbedCreated` callback invocation.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Element} embed\n *         The embed DOM element.\n *\n * @return {Element}\n *         A possibly-new DOM element.\n */\n\n\nvar onEmbedCreated = function onEmbedCreated(params, embed) {\n  if (typeof params.onEmbedCreated !== 'function') {\n    return embed;\n  }\n\n  var result = params.onEmbedCreated(embed);\n\n  if (isEl(result)) {\n    return result;\n  }\n\n  return embed;\n};\n/**\n * Creates an embed code of the appropriate type, runs any customizations\n * necessary, and inserts it into the DOM.\n *\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @return {Element}\n *         The DOM element that will ultimately be passed to the `bc()`\n *         function. Even when customized or wrapped, the return value will be\n *         the target element.\n */\n\n\nvar createEmbed = function createEmbed(params) {\n  var embed = params.embedType === EMBED_TYPE_IFRAME ? createIframeEmbed(params) : createInPageEmbed(params);\n  return insertEmbed(params, onEmbedCreated(params, embed));\n};\n\n//\n// The keys follow the format \"accountId_playerId_embedId\" where accountId is\n// optional and defaults to \"*\". This happens when we detect pre-existing\n// player globals.\n\nvar actualCache = new window.Map();\n/**\n * Get the cache key given some properties.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID.\n *\n * @return {string}\n *         A key to be used in the script cache.\n */\n\nvar key = function key(_ref) {\n  var accountId = _ref.accountId,\n      playerId = _ref.playerId,\n      embedId = _ref.embedId;\n  return (accountId || '*') + \"_\" + playerId + \"_\" + embedId;\n};\n/**\n * Add an entry to the script cache.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID. If not given, we assume that no script was\n *         downloaded for this player.\n */\n\n\nvar store = function store(props) {\n  actualCache.set(key(props), props.accountId ? urls.getUrl(props) : '');\n};\n/**\n * Checks if the script cache has an entry.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID.\n *\n * @return {boolean}\n *         Will be `true` if there is a matching cache entry.\n */\n\n\nvar has = function has(props) {\n  return actualCache.has(key(props));\n};\n/**\n * Gets a cache entry.\n *\n * @private\n * @param  {Object} props\n *         Properties describing the player record to cache.\n *\n * @param  {string} props.playerId\n *         A player ID.\n *\n * @param  {string} props.embedId\n *         An embed ID.\n *\n * @param  {string} [props.accountId=\"*\"]\n *         An optional account ID. This is optional because when we search for\n *         pre-existing players to avoid downloads, we will not necessarily\n *         know the account ID.\n *\n * @return {string}\n *         A cache entry - a URL or empty string.\n *\n */\n\n\nvar get = function get(props) {\n  return actualCache.get(key(props));\n};\n/**\n * Clears the cache.\n */\n\n\nvar clear = function clear() {\n  actualCache.clear();\n};\n/**\n * Iterates over the cache.\n *\n * @param  {Function} fn\n *         A callback function that will be called with a value and a key\n *         for each item in the cache.\n */\n\n\nvar forEach = function forEach(fn) {\n  actualCache.forEach(fn);\n};\n\nvar playerScriptCache = {\n  clear: clear,\n  forEach: forEach,\n  get: get,\n  has: has,\n  key: key,\n  store: store\n};\n\nvar REGEX_PLAYER_EMBED = /^([A-Za-z0-9]+)_([A-Za-z0-9]+)$/;\n/**\n * Gets an array of current per-player/per-embed `bc` globals that are\n * attached to the `bc` global (e.g. `bc.abc123xyz_default`).\n *\n * If `bc` is not defined, returns an empty array.\n *\n * @private\n * @return {string[]}\n *         An array of keys.\n */\n\nvar getBcGlobalKeys = function getBcGlobalKeys() {\n  return window.bc ? Object.keys(window.bc).filter(function (k) {\n    return REGEX_PLAYER_EMBED.test(k);\n  }) : [];\n};\n/**\n * Gets known global object keys that Brightcove Players may create.\n *\n * @private\n * @return {string[]}\n *         An array of global variables that were added during testing.\n */\n\n\nvar getGlobalKeys = function getGlobalKeys() {\n  return Object.keys(window).filter(function (k) {\n    return /^videojs/i.test(k) || /^(bc)$/.test(k);\n  });\n};\n/**\n * Dispose all players from a copy of Video.js.\n *\n * @param  {Function} videojs\n *         A copy of Video.js.\n */\n\n\nvar disposeAll = function disposeAll(videojs) {\n  if (!videojs) {\n    return;\n  }\n\n  Object.keys(videojs.players).forEach(function (k) {\n    var p = videojs.players[k];\n\n    if (p) {\n      p.dispose();\n    }\n  });\n};\n/**\n * Resets environment state.\n *\n * This will dispose ALL Video.js players on the page and remove ALL `bc` and\n * `videojs` globals it finds.\n */\n\n\nvar reset = function reset() {\n  // Remove all script elements from the DOM.\n  playerScriptCache.forEach(function (value, key) {\n    // If no script URL is associated, skip it.\n    if (!value) {\n      return;\n    } // Find all script elements and remove them.\n\n\n    Array.prototype.slice.call(document.querySelectorAll(\"script[src=\\\"\" + value + \"\\\"]\")).forEach(function (el) {\n      return el.parentNode.removeChild(el);\n    });\n  }); // Clear the internal cache that have been downloaded.\n\n  playerScriptCache.clear(); // Dispose any remaining players from the `videojs` global.\n\n  disposeAll(window.videojs); // There may be other `videojs` instances lurking in the bowels of the\n  // `bc` global. This should eliminate any of those.\n\n  getBcGlobalKeys().forEach(function (k) {\n    return disposeAll(window.bc[k].videojs);\n  }); // Delete any global object keys that were created.\n\n  getGlobalKeys().forEach(function (k) {\n    delete window[k];\n  });\n};\n/**\n * At runtime, populate the cache with pre-detected players. This allows\n * people who have bundled their player or included a script tag before this\n * runs to not have to re-download players.\n */\n\n\nvar detectPlayers = function detectPlayers() {\n  getBcGlobalKeys().forEach(function (k) {\n    var matches = k.match(REGEX_PLAYER_EMBED);\n    var props = {\n      playerId: matches[1],\n      embedId: matches[2]\n    };\n\n    if (!playerScriptCache.has(props)) {\n      playerScriptCache.store(props);\n    }\n  });\n};\n\nvar env = {\n  detectPlayers: detectPlayers,\n  reset: reset\n};\n\nenv.detectPlayers();\n/**\n * Is this value a function?\n *\n * @private\n * @param  {Function} fn\n *         A maybe function.\n *\n * @return {boolean}\n *         Whether or not the value is a function.\n */\n\nvar isFn = function isFn(fn) {\n  return typeof fn === 'function';\n};\n/**\n * Checks whether an embedType parameter is valid.\n *\n * @private\n * @param  {string} embedType\n *         The value to test.\n *\n * @return {boolean}\n *         Whether the value is valid.\n */\n\n\nvar isValidEmbedType = function isValidEmbedType(embedType) {\n  return embedType === EMBED_TYPE_IN_PAGE || embedType === EMBED_TYPE_IFRAME;\n};\n/**\n * Checks whether an embedOptions.tagName parameter is valid.\n *\n * @private\n * @param  {string} tagName\n *         The value to test.\n *\n * @return {boolean}\n *         Whether the value is valid.\n */\n\n\nvar isValidTagName = function isValidTagName(tagName) {\n  return tagName === EMBED_TAG_NAME_VIDEOJS || tagName === EMBED_TAG_NAME_VIDEO;\n};\n/**\n * Checks whether a refNodeInsert parameter is valid.\n *\n * @private\n * @param  {string} refNodeInsert\n *         The value to test.\n *\n * @return {boolean}\n *         Whether the value is valid.\n */\n\n\nvar isValidRootInsert = function isValidRootInsert(refNodeInsert) {\n  return refNodeInsert === REF_NODE_INSERT_APPEND || refNodeInsert === REF_NODE_INSERT_PREPEND || refNodeInsert === REF_NODE_INSERT_BEFORE || refNodeInsert === REF_NODE_INSERT_AFTER || refNodeInsert === REF_NODE_INSERT_REPLACE;\n};\n/**\n * Checks parameters and throws an error on validation problems.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @throws {Error} If accountId is missing.\n * @throws {Error} If refNode is missing or invalid.\n * @throws {Error} If embedType is missing or invalid.\n * @throws {Error} If attempting to use an iframe embed with options.\n * @throws {Error} If attempting to use embedOptions.responsiveIframe with a\n *                 non-iframe embed.\n * @throws {Error} If refNodeInsert is missing or invalid.\n */\n\n\nvar checkParams = function checkParams(params) {\n  var accountId = params.accountId,\n      embedOptions = params.embedOptions,\n      embedType = params.embedType,\n      options = params.options,\n      refNode = params.refNode,\n      refNodeInsert = params.refNodeInsert;\n\n  if (!accountId) {\n    throw new Error('accountId is required');\n  } else if (!isElInDom(refNode)) {\n    throw new Error('refNode must resolve to a node attached to the DOM');\n  } else if (!isValidEmbedType(embedType)) {\n    throw new Error('embedType is missing or invalid');\n  } else if (embedType === EMBED_TYPE_IFRAME && options) {\n    throw new Error('cannot use options with an iframe embed');\n  } else if (embedOptions && embedOptions.tagName !== undefined && !isValidTagName(embedOptions.tagName)) {\n    throw new Error(\"embedOptions.tagName is invalid (value: \\\"\" + embedOptions.tagName + \"\\\")\");\n  } else if (embedOptions && embedOptions.responsive && embedOptions.responsive.aspectRatio && !/^\\d+\\:\\d+$/.test(embedOptions.responsive.aspectRatio)) {\n    throw new Error(\"embedOptions.responsive.aspectRatio must be in the \\\"n:n\\\" format (value: \\\"\" + embedOptions.responsive.aspectRatio + \"\\\")\");\n  } else if (!isValidRootInsert(refNodeInsert)) {\n    throw new Error('refNodeInsert is missing or invalid');\n  }\n};\n/**\n * Normalizes a `refNode` param to an element - or `null`.\n *\n * @private\n * @param  {Element|string} refNode\n *         The value of a `refNode` param.\n *\n * @return {Element|null}\n *         A DOM element or `null` if the `refNode` was given as a string and\n *         did not match an element.\n */\n\n\nvar resolveRefNode = function resolveRefNode(refNode) {\n  if (isElInDom(refNode)) {\n    return refNode;\n  }\n\n  if (typeof refNode === 'string') {\n    return document.querySelector(refNode);\n  }\n\n  return null;\n};\n/**\n * Initializes a player and returns it.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Element} embed\n *         An element that will be passed to the `bc()` function.\n *\n * @param  {Function} resolve\n *         A function to call if a player is successfully initialized.\n *\n * @param  {Function} reject\n *         A function to call if a player fails to be initialized.\n *\n * @return {Object}\n *         A success object whose `ref` is a player.\n */\n\n\nvar initPlayer = function initPlayer(params, embed, resolve, reject) {\n  var embedId = params.embedId,\n      playerId = params.playerId;\n  var bc = window.bc[playerId + \"_\" + embedId] || window.bc;\n\n  if (!bc) {\n    return reject(new Error(\"missing bc function for \" + playerId));\n  }\n\n  playerScriptCache.store(params);\n  var player;\n\n  try {\n    player = bc(embed, params.options); // Add a PLAYER_LOADER property to bcinfo to indicate this player was\n    // loaded via that mechanism.\n\n    if (player.bcinfo) {\n      player.bcinfo.PLAYER_LOADER = true;\n    }\n  } catch (x) {\n    var message = 'Could not initialize the Brightcove Player.'; // Update the rejection message based on known conditions that can cause it.\n\n    if (params.embedOptions.tagName === EMBED_TAG_NAME_VIDEOJS) {\n      message += ' You are attempting to embed using a \"video-js\" element.' + ' Please ensure that your Player is v6.11.0 or newer in order to' + ' support this embed type. Alternatively, pass `\"video\"` for' + ' `embedOptions.tagName`.';\n    }\n\n    return reject(new Error(message));\n  }\n\n  resolve({\n    type: EMBED_TYPE_IN_PAGE,\n    ref: player\n  });\n};\n/**\n * Loads a player from CDN and embeds it.\n *\n * @private\n * @param  {Object} params\n *         A parameters object. See README for details.\n *\n * @param  {Function} resolve\n *         A function to call if a player is successfully initialized.\n *\n * @param  {Function} reject\n *         A function to call if a player fails to be initialized.\n */\n\n\nvar loadPlayer = function loadPlayer(params, resolve, reject) {\n  params.refNode = resolveRefNode(params.refNode);\n  checkParams(params);\n  var refNode = params.refNode,\n      refNodeInsert = params.refNodeInsert; // Store a reference to the refNode parent. When we use the replace method,\n  // we'll need it as the location to store the script element.\n\n  var refNodeParent = refNode.parentNode;\n  var embed = createEmbed(params); // If this is an iframe, all we need to do is create the embed code and\n  // inject it. Because there is no reliable way to hook into an iframe from\n  // the parent page, we simply resolve immediately upon creating the embed.\n\n  if (params.embedType === EMBED_TYPE_IFRAME) {\n    resolve({\n      type: EMBED_TYPE_IFRAME,\n      ref: embed\n    });\n    return;\n  } // If we've already downloaded this script or detected a matching global, we\n  // should have the proper `bc` global and can bypass the script creation\n  // process.\n\n\n  if (playerScriptCache.has(params)) {\n    return initPlayer(params, embed, resolve, reject);\n  }\n\n  var script = document.createElement('script');\n\n  script.onload = function () {\n    return initPlayer(params, embed, resolve, reject);\n  };\n\n  script.onerror = function () {\n    reject(new Error('player script could not be downloaded'));\n  };\n\n  script.async = true;\n  script.charset = 'utf-8';\n  script.src = urls.getUrl(params);\n\n  if (refNodeInsert === REF_NODE_INSERT_REPLACE) {\n    refNodeParent.appendChild(script);\n  } else {\n    refNode.appendChild(script);\n  }\n};\n/**\n * A function for asynchronously loading a Brightcove Player into a web page.\n *\n * @param  {Object} parameters\n *         A parameters object. See README for details.\n *\n * @return {Promise|undefined}\n *         A Promise, if possible.\n */\n\n\nvar brightcovePlayerLoader = function brightcovePlayerLoader(parameters) {\n  var params = _extends$1({}, DEFAULTS, parameters);\n\n  var Promise = params.Promise,\n      onSuccess = params.onSuccess,\n      onFailure = params.onFailure; // When Promise is not available or any success/failure callback is given,\n  // do not attempt to use Promises.\n\n  if (!isFn(Promise) || isFn(onSuccess) || isFn(onFailure)) {\n    return loadPlayer(params, isFn(onSuccess) ? onSuccess : function () {}, isFn(onFailure) ? onFailure : function (err) {\n      throw err;\n    });\n  } // Promises are supported, use 'em.\n\n\n  return new Promise(function (resolve, reject) {\n    return loadPlayer(params, resolve, reject);\n  });\n};\n/**\n * Expose a non-writable, non-configurable property on the\n * `brightcovePlayerLoader` function.\n *\n * @private\n * @param  {string} key\n *         The property key.\n *\n * @param  {string|Function} value\n *         The value.\n */\n\n\nvar expose = function expose(key, value) {\n  Object.defineProperty(brightcovePlayerLoader, key, {\n    configurable: false,\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n};\n/**\n * Get the base URL for players. By default, this will be the Brightcove CDN.\n *\n * @return {string}\n *         The current base URL.\n */\n\n\nexpose('getBaseUrl', function () {\n  return urls.getBaseUrl();\n});\n/**\n * Set the base URL for players. By default, this will be the Brightcove CDN,\n * but can be overridden with this function.\n *\n * @param {string} baseUrl\n *        A new base URL (instead of Brightcove CDN).\n */\n\nexpose('setBaseUrl', function (baseUrl) {\n  urls.setBaseUrl(baseUrl);\n});\n/**\n * Get the URL for a player.\n */\n\nexpose('getUrl', function (options) {\n  return urls.getUrl(options);\n});\n/**\n * Completely resets global state.\n *\n * This will dispose ALL Video.js players on the page and remove ALL `bc` and\n * `videojs` globals it finds.\n */\n\nexpose('reset', function () {\n  return env.reset();\n}); // Define some read-only constants on the exported function.\n\n[['EMBED_TAG_NAME_VIDEO', EMBED_TAG_NAME_VIDEO], ['EMBED_TAG_NAME_VIDEOJS', EMBED_TAG_NAME_VIDEOJS], ['EMBED_TYPE_IN_PAGE', EMBED_TYPE_IN_PAGE], ['EMBED_TYPE_IFRAME', EMBED_TYPE_IFRAME], ['REF_NODE_INSERT_APPEND', REF_NODE_INSERT_APPEND], ['REF_NODE_INSERT_PREPEND', REF_NODE_INSERT_PREPEND], ['REF_NODE_INSERT_BEFORE', REF_NODE_INSERT_BEFORE], ['REF_NODE_INSERT_AFTER', REF_NODE_INSERT_AFTER], ['REF_NODE_INSERT_REPLACE', REF_NODE_INSERT_REPLACE], ['VERSION', version]].forEach(function (arr) {\n  expose(arr[0], arr[1]);\n});\n\n/**\n * These prop changes can be handled by an internal player state change rather\n * than a full dispose/recreate.\n *\n * @private\n * @type {Object}\n */\n\nvar UPDATEABLE_PROPS = ['catalogSearch', 'catalogSequence', 'playlistId', 'playlistVideoId', 'videoId'];\n\nvar logError = function logError(err) {\n  /* eslint-disable no-console */\n  if (err && console && console.error) {\n    console.error(err);\n  }\n  /* eslint-enable no-console */\n\n};\n/**\n * The official React component for the Brightcove Player!\n *\n * This uses `@brightcove/player-loader` to load a player into a React\n * component based on the given props.\n */\n\n\nvar ReactPlayerLoader =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(ReactPlayerLoader, _React$Component);\n\n  /**\n   * Create a new Brightcove player.\n   *\n   * @param {Object} props\n   *        Most options will be passed along to player-loader, except for\n   *        options that are listed. See README.md for more detail.\n   *\n   * @param {string} [props.baseUrl]\n   *        The base URL to use when requesting a player\n   *\n   * @param {Object} [props.attrs]\n   *        Used to set attributes on the component element that contains the\n   *        embedded Brightcove Player.\n   *\n   * @param {boolean} [props.manualReloadFromPropChanges]\n   *        Used to specify if reloading the player after prop changes will be handled manually.\n   *\n   */\n  function ReactPlayerLoader(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.refNode = null;\n\n    _this.setRefNode = function (ref) {\n      _this.refNode = ref;\n    };\n\n    _this.loadPlayer = _this.loadPlayer.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Loads a new player based on the current props.\n   */\n\n\n  var _proto = ReactPlayerLoader.prototype;\n\n  _proto.loadPlayer = function loadPlayer() {\n    var _this2 = this;\n\n    // If there is any player currently loaded, dispose it before fetching a\n    // new one.\n    this.disposePlayer(); // We need to provide our own callbacks below, so we cache these\n    // user-provided callbacks for use later.\n\n    var userSuccess = this.props.onSuccess;\n    var userFailure = this.props.onFailure;\n\n    var options = _extends({}, this.props, {\n      refNode: this.refNode,\n      refNodeInsert: 'append',\n      onSuccess: function onSuccess(_ref) {\n        var ref = _ref.ref,\n            type = _ref.type;\n\n        // If the component is not mounted when the callback fires, dispose\n        // the player and bail out.\n        if (!_this2.isMounted_) {\n          _this2.disposePlayer(ref);\n\n          return;\n        } // Store a player reference on the component.\n\n\n        _this2.player = ref; // Null out the player reference when the player is disposed from\n        // outside the component.\n\n        if (type === 'in-page') {\n          ref.one('dispose', function () {\n            _this2.player = null;\n          });\n        } // Add a REACT_PLAYER_LOADER property to bcinfo to indicate this player\n        // was loaded via that mechanism.\n\n\n        if (ref.bcinfo) {\n          ref.bcinfo.REACT_PLAYER_LOADER = true;\n        } // Call a user-provided onSuccess callback.\n\n\n        if (typeof userSuccess === 'function') {\n          userSuccess({\n            ref: ref,\n            type: type\n          });\n        }\n      },\n      onFailure: function onFailure(error) {\n        // Ignore errors when not mounted.\n        if (!_this2.isMounted_) {\n          return;\n        } // Call a user-provided onFailure callback.\n\n\n        if (typeof userFailure === 'function') {\n          userFailure(error);\n          return;\n        } // Fall back to throwing an error;\n\n\n        throw new Error(error);\n      }\n    }); // Delete props that are not meant to be passed to player-loader.\n\n\n    delete options.attrs;\n    delete options.baseUrl;\n    delete options.manualReloadFromPropChanges; // If a base URL is provided, it should only apply to this player load.\n    // This means we need to back up the original base URL and restore it\n    // _after_ we call player loader.\n\n    var originalBaseUrl = brightcovePlayerLoader.getBaseUrl();\n\n    if (this.props.baseUrl) {\n      brightcovePlayerLoader.setBaseUrl(this.props.baseUrl);\n    }\n\n    brightcovePlayerLoader(options);\n    brightcovePlayerLoader.setBaseUrl(originalBaseUrl);\n  }\n  /**\n   * Disposes the current player, if there is one.\n   */\n  ;\n\n  _proto.disposePlayer = function disposePlayer() {\n    // Nothing to dispose.\n    if (!this.player) {\n      return;\n    } // Dispose an in-page player.\n\n\n    if (this.player.dispose) {\n      this.player.dispose(); // Dispose an iframe player.\n    } else if (this.player.parentNode) {\n      this.player.parentNode.removeChild(this.player);\n    } // Null out the player reference.\n\n\n    this.player = null;\n  }\n  /**\n   * Find the index of the `playlistVideoId` prop within the player's playlist.\n   *\n   * @param  {Object[]} playlist\n   *         An array of playlist item objects.\n   *\n   * @return {number}\n   *         The index of the `playlistVideoId` or `-1` if the player has been\n   *         disposed, is not using the playlist plugin, or if not found.\n   */\n  ;\n\n  _proto.findPlaylistVideoIdIndex_ = function findPlaylistVideoIdIndex_(playlist) {\n    var playlistVideoId = this.props.playlistVideoId;\n\n    if (Array.isArray(playlist) && playlistVideoId) {\n      for (var i = 0; i < playlist.length; i++) {\n        var _playlist$i = playlist[i],\n            id = _playlist$i.id,\n            referenceId = _playlist$i.referenceId;\n\n        if (id === playlistVideoId || \"ref:\" + referenceId === playlistVideoId) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Create a Playback API callback function for the component's player.\n   *\n   * @private\n   * @param  {string} requestType\n   *         The Playback API request type (e.g. \"video\" or \"playlist\").\n   *\n   * @param  {Object} changes\n   *         An object. The keys of this object are the props that changed.\n   *\n   * @return {Function}\n   *         A callback for the Playback API request.\n   */\n  ;\n\n  _proto.createPlaybackAPICallback_ = function createPlaybackAPICallback_(requestType, changes) {\n    var _this3 = this;\n\n    return function (err, data) {\n      if (err) {\n        logError(err);\n        return;\n      } // If the playlistVideoId changed and this is a playlist request, we\n      // need to search through the playlist items to find the correct\n      // starting index.\n\n\n      if (requestType === 'playlist' && changes.playlistVideoId) {\n        var i = _this3.findPlaylistVideoIdIndex_(data);\n\n        if (i > -1) {\n          data.startingIndex = i;\n        }\n      }\n\n      _this3.player.catalog.load(data);\n    };\n  }\n  /**\n   * Update the player based on changes to certain props that do not require\n   * a full player dispose/recreate.\n   *\n   * @param {Object} changes\n   *        An object. The keys of this object are the props that changed.\n   */\n  ;\n\n  _proto.updatePlayer = function updatePlayer(changes) {\n    // No player exists, player is disposed, or not using the catalog\n    if (!this.player || !this.player.el || !this.player.el()) {\n      return;\n    } // If the player is using the catalog plugin, we _may_ populate this\n    // variable with an object.\n\n\n    var catalogParams;\n\n    if (this.player.usingPlugin('catalog')) {\n      // There is a new catalog sequence request. This takes precedence over\n      // other catalog updates because it is a different call.\n      if (changes.catalogSequence && this.props.catalogSequence) {\n        var callback = this.createPlaybackAPICallback_('sequence', changes);\n        this.player.catalog.getLazySequence(this.props.catalogSequence, callback, this.props.adConfigId);\n        return;\n      }\n\n      if (changes.videoId && this.props.videoId) {\n        catalogParams = {\n          type: 'video',\n          id: this.props.videoId\n        };\n      } else if (changes.playlistId && this.props.playlistId) {\n        catalogParams = {\n          type: 'playlist',\n          id: this.props.playlistId\n        };\n      } else if (changes.catalogSearch && this.props.catalogSearch) {\n        catalogParams = {\n          type: 'search',\n          q: this.props.catalogSearch\n        };\n      }\n    } // If `catalogParams` is `undefined` here, that means the player either\n    // does not have the catalog plugin or no valid catalog request can be made.\n\n\n    if (catalogParams) {\n      if (this.props.adConfigId) {\n        catalogParams.adConfigId = this.props.adConfigId;\n      }\n\n      if (this.props.deliveryConfigId) {\n        catalogParams.deliveryConfigId = this.props.deliveryConfigId;\n      } // We use the callback style here to make tests simpler in IE11 (no need\n      // for a Promise polyfill).\n\n\n      var _callback = this.createPlaybackAPICallback_(catalogParams.type, changes);\n\n      this.player.catalog.get(catalogParams, _callback); // If no catalog request is being made, we may still need to update the\n      // playlist selected video.\n    } else if (changes.playlistVideoId && this.props.playlistVideoId && this.player.usingPlugin('playlist')) {\n      var i = this.findPlaylistVideoIdIndex_(this.player.playlist());\n\n      if (i > -1) {\n        this.player.playlist.currentItem(i);\n      }\n    }\n  }\n  /**\n   * Called just after the component has mounted.\n   */\n  ;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.isMounted_ = true;\n    this.loadPlayer();\n  }\n  /**\n   * Called when the component props are updated.\n   *\n   * Some prop changes may trigger special behavior (see `propChangeHandlers`),\n   * but if ANY prop is changed that is NOT handled, the player will be\n   * disposed/recreated entirely.\n   *\n   * @param  {Object} prevProps\n   *         The previous props state before change.\n   */\n  ;\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this4 = this;\n\n    // Calculate the prop changes.\n    var changes = Object.keys(prevProps).reduce(function (acc, key) {\n      var previous = prevProps[key];\n      var current = _this4.props[key]; // Do not compare functions\n\n      if (typeof current === 'function') {\n        return acc;\n      }\n\n      if (typeof current === 'object' && current !== null) {\n        if (JSON.stringify(current) !== JSON.stringify(previous)) {\n          acc[key] = true;\n        }\n\n        return acc;\n      }\n\n      if (current !== previous) {\n        acc[key] = true;\n      }\n\n      return acc;\n    }, {});\n\n    if (!this.props.manualReloadFromPropChanges) {\n      // Dispose and recreate the player if any changed keys cannot be handled.\n      if (Object.keys(changes).some(function (k) {\n        return UPDATEABLE_PROPS.indexOf(k) === -1;\n      })) {\n        this.loadPlayer();\n        return;\n      }\n    }\n\n    this.updatePlayer(changes);\n  }\n  /**\n   * Called just before a component unmounts. Disposes the player.\n   */\n  ;\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.isMounted_ = false;\n    this.disposePlayer();\n  }\n  /**\n   * Renders the component.\n   *\n   * @return {ReactElement}\n   *          The react element to render.\n   */\n  ;\n\n  _proto.render = function render() {\n    var props = _extends({\n      className: 'brightcove-react-player-loader'\n    }, this.props.attrs, {\n      ref: this.setRefNode\n    });\n\n    return React.createElement('div', props);\n  };\n\n  return ReactPlayerLoader;\n}(React.Component);\n\nexport default ReactPlayerLoader;\n"]}